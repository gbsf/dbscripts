#!/bin/bash

. "$(dirname $0)/config"
. "$(dirname $0)/db-functions"

if (( $# >= 1 )); then
	warning "Calling %s with a specific repository is no longer supported" "${0##*/}"
	exit 1
fi

# Find repos with packages to release
if ! staging_repos=($(find  "${STAGING}" -mindepth 1 -type f -name "*${PKGEXT}" -printf '%h\n' | sort -u)); then
	die "Could not read %s" "$STAGING"
fi

repos=()
for staging_repo in ${staging_repos[@]##*/}; do
	if in_array ${staging_repo} ${PKGREPOS[@]}; then
		repos+=(${staging_repo})
	fi
done

# TODO: this might lock too much (architectures)
for repo in ${repos[@]}; do
	for pkgarch in ${ARCHES[@]}; do
		repo_lock ${repo} ${pkgarch} || exit 1
	done
done

# check if packages are valid
for repo in ${repos[@]}; do
	if ! check_repo_permission "${repo}"; then
		die "You don't have permission to update packages in %s" "$repo"
	fi
	pkgs=($(getpkgfiles "${STAGING}/${repo}/"*${PKGEXT}))
	if (( $? == 0 )); then
		for pkg in ${pkgs[@]}; do
			if [[ -h ${pkg} ]]; then
				die "Package %s is a symbolic link" "$repo/${pkg##*/}"
			fi
			if ! check_pkgfile "${pkg}"; then
				die "Package %s is not consistent with its meta data" "$repo/${pkg##*/}"
			fi
			if ! pacman-key -v "${pkg}.sig" >/dev/null 2>&1; then
				die "Package %s does not have a valid signature" "$repo/${pkg##*/}"
			fi
			if ! check_pkgrepos "${pkg}"; then
				die "Package %s already exists in another repository" "$repo/${pkg##*/}"
			fi
			if ! check_packager "${pkg}"; then
				die "Package %s does not have a valid packager" "$repo/${pkg##*/}"
			fi
			if ! check_buildinfo "${pkg}"; then
				die "Package %s does not have a .BUILDINFO file" "$repo/${pkg##*/}"
			fi
			if ! check_builddir "${pkg}"; then
				die "Package %s was not built in a chroot" "$repo/${pkg##*/}"
			fi
		done
	else
		die "Could not read %s" "$STAGING"
	fi
done

for repo in ${repos[@]}; do
	for pkgfile in $(getpkgfiles "${STAGING}/${repo}/"*${PKGEXT} 2>/dev/null); do
		arch_add_to_pool "$pkgfile"
	done

	for file in "$STAGING/$repo"/*/*; do
		if [[ -h $file ]]; then
			pkgfiles=("${pkgfiles[@]}" "${file##*/}")
		fi
	done

	for pkgarch in ${ARCHES[@]}; do
		declare -a pkgs_to_add=()
		for pkgfile in "${pkgfiles[@]}"; do
			pkgfile_arch="$STAGING/$repo/$pkgarch/$pkgfile"
			if [[ -h "$pkgfile_arch" ]]; then
				pkgs_to_add=("${pkgs_to_add[@]}" "$pkgfile")
				rm "$pkgfile_arch"
			fi
		done
		arch_db_add $repo "$pkgarch" "${pkgs_to_add[@]}"
	done
done

arch_history_commit "db-update: ${repos[@]}"

for repo in ${repos[@]}; do
	for pkgarch in ${ARCHES[@]}; do
		repo_unlock ${repo} ${pkgarch}
	done
done
